#!/usr/bin/env python3
# Copyright 2024 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

import argparse
import os
import sys
import math

license = """\
// Copyright 2024 ETH Zurich and University of Bologna.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
"""

script_path = "scripts/gen_xbar.py"

def gen_header(command):
    header = license
    header += '// Automatically generated by:\n'
    header += f'// {script_path} {command}\n'
    return header

def clog2(x):
    if x < 1:
        raise ValueError("clog2 is not defined for numbers less than 1")
    return math.ceil(math.log2(x))

def generate_crossbar(InNum, OutNum):
    # module_name = f"selector_{InNum}to{OutNum}"
    module_name = f"selector"
    
    # Generate inputs and outputs
    inputs = [f"input  logic [InNum-1:0] req_vector_i"]
    inputs.append("input  logic [$clog2(InNum)-1:0] priority_i")
    outputs = [f"output logic [OutNum-1:0][$clog2(InNum)-1:0] sel_inport_idx_o"]
    outputs.append("output logic [InNum-1:0][$clog2(OutNum)-1:0] asn_outport_idx_o")
    outputs.append("output logic [InNum-1:0]                     asn_outport_vld_o")

    # Generate the assertion
    assertion = f"initial begin\n"
    assertion += f"    assert (InNum == {InNum}) else $fatal(1, \"Parameter InNum does not match expected value {InNum}\");\n"
    assertion += f"    assert (OutNum == {OutNum}) else $fatal(1, \"Parameter OutNum does not match expected value {OutNum}\");\n"
    assertion += f"end\n"

    # Generate variable declaration
    declaration     = "logic [OutNum-1:0][$clog2(InNum)-1:0] sel_inport_idx_raw;\n"
    declaration    += "logic [OutNum-1:0]                    sel_inport_idx_raw_vld;\n"
    declaration    += "logic [InNum-1:0]                     req_vector_rotate;\n"
    
    # Generate req_vector_i logic
    priority_logic  = "assign req_vector_rotate = (priority_i == '0) ? req_vector_i :\n"
    priority_logic += "                           "
    priority_logic += "((req_vector_i << (InNum -priority_i)) | (req_vector_i >> priority_i));\n"

    # Generate output logic
    output_logic  = "\nalways_comb begin\n"
    output_logic += "    for(int i = 0; i < OutNum; i++) begin\n"
    output_logic += "        if(sel_inport_idx_raw[i] < (InNum - priority_i)) begin\n"
    output_logic += "            sel_inport_idx_o[i] = sel_inport_idx_raw [i] + priority_i;\n"
    output_logic += "        end else begin\n"
    output_logic += "            sel_inport_idx_o[i] = sel_inport_idx_raw [i] - (InNum - priority_i);\n"
    output_logic += "        end\n"
    output_logic += "    end\n"
    output_logic += "end\n"


    output_logic += "\nalways_comb begin\n"
    output_logic += "    asn_outport_idx_o = '0;\n"
    output_logic += "    asn_outport_vld_o = '0;\n"
    output_logic += "    for(int i = 0; i < OutNum; i++) begin\n"
    output_logic += "        if(sel_inport_idx_raw_vld[i] == 1'b1) begin\n"
    output_logic += "            asn_outport_idx_o[sel_inport_idx_o[i]] = i;\n"
    output_logic += "            asn_outport_vld_o[sel_inport_idx_o[i]] = 1'b1;\n"
    output_logic += "        end\n"
    output_logic += "    end\n"
    output_logic += "end\n"


    # Generate switch case logic for crossbar
    switch_case = "always_comb begin\n"
    switch_case += "    sel_inport_idx_raw     = '0;\n"
    switch_case += "    sel_inport_idx_raw_vld = '0;\n"
    switch_case += "    case (req_vector_rotate)\n"
    for i in range(2**InNum):
        case_str = bin(i)[2:].zfill(InNum)
        switch_case += f"        {InNum}'b{case_str}: begin\n"
        set_bits = [j for j in range(InNum) if case_str[InNum-1-j] == '1']
        for n in range(OutNum):
            if n < len(set_bits):
                switch_case += f"            sel_inport_idx_raw    [{n}] = {clog2(InNum)}'d{set_bits[n]};\n"
                switch_case += f"            sel_inport_idx_raw_vld[{n}] = 1'b1;\n"
            else:
                switch_case += f"            sel_inport_idx_raw    [{n}] = {clog2(InNum)}'d0;\n"
                switch_case += f"            sel_inport_idx_raw_vld[{n}] = 1'b0;\n"
        switch_case += "        end\n"
    switch_case += "        default: /*do nothing */;\n"
    switch_case += "    endcase\n"
    switch_case += "end\n"

    # Generate final module
    sv_code = f"module {module_name} #(\n"
    sv_code += f"    parameter int InNum = {InNum},\n"
    sv_code += f"    parameter int OutNum = {OutNum}\n"
    sv_code += f") (\n"
    sv_code += "    " + ",\n    ".join(inputs)
    sv_code += f",\n"
    sv_code += "    " + ",\n    ".join(outputs)
    # sv_code += "".join(outputs)
    sv_code += "\n);\n\n"
    sv_code += assertion + "\n"
    sv_code += declaration + "\n"
    sv_code += priority_logic + "\n"
    sv_code += output_logic + "\n"
    sv_code += switch_case + "\n"
    sv_code += "endmodule\n"

    return sv_code

def main():
    # Validate and parse InNum and OutNum
    parser = argparse.ArgumentParser('gen_data', allow_abbrev=True)
    parser.add_argument(
        '-in',
        '--input_num',
        nargs='+',
        action='append',
        help='Input port number'
    )
    parser.add_argument(
        '-on',
        '--output_num',
        nargs='+',
        action='append',
        help='Output port number'
    )
    parser.add_argument(
        '-o',
        '--output',
        nargs=1,
        help='Output header file')

    args = parser.parse_args()
    file = args.output[0]

    # Generate SystemVerilog code
    print(f"\ninput_num={int(args.input_num[0][0])}, output_num={int(args.output_num[0][0])}, output_dir={file}\n")
    sv_code = generate_crossbar(int(args.input_num[0][0]), int(args.output_num[0][0]))

    # Write the file
    with open(file, "w") as f:
        f.write(gen_header(' '.join(sys.argv[1:])))
        f.write(sv_code)

if __name__ == "__main__":
    main()
